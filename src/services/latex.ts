import { config } from '../config.ts';
import type { DocumentRequest } from '../config.ts';
import { spawn } from 'child_process';
import { promises as fs } from 'fs';
import path from 'path';

export class LaTeXService {
  private template: string;
  private outputFormat: string;
  private outputDir: string;

  constructor() {
    this.template = config.latex.template;
    this.outputFormat = config.latex.outputFormat;
    this.outputDir = path.join(process.cwd(), 'output');
    this.ensureOutputDirectory();
  }

  private async ensureOutputDirectory(): Promise<void> {
    try {
      await fs.access(this.outputDir);
    } catch {
      await fs.mkdir(this.outputDir, { recursive: true });
    }
  }

  generateDocument(request: DocumentRequest, chapters: string[]): string {
    const { topic, complexity, chapters: chapterCount } = request;
    
    const documentHeader = this.generateDocumentHeader(topic, complexity);
    const tableOfContents = this.generateTableOfContents();
    const chaptersContent = chapters.join('\n\n');
    const documentFooter = this.generateDocumentFooter();

    return `${documentHeader}\n\n${tableOfContents}\n\n${chaptersContent}\n\n${documentFooter}`;
  }

  private generateDocumentHeader(topic: string, complexity: string): string {
    const complexityLabel = complexity.charAt(0).toUpperCase() + complexity.slice(1);
    
    return `\\documentclass[12pt]{article}
\\usepackage[utf8]{inputenc}
\\usepackage[T1]{fontenc}
\\usepackage{geometry}
\\usepackage{amsmath}
\\usepackage{amsfonts}
\\usepackage{amssymb}
\\usepackage{graphicx}
\\usepackage{hyperref}
\\usepackage{fancyhdr}
\\usepackage{tocloft}
\\usepackage{listings}
\\usepackage{xcolor}

% Improved formatting fixes
\\geometry{margin=1in}
\\setlength{\\headheight}{15pt}  % Fix header height warning
\\addtolength{\\topmargin}{-3pt} % Compensate for header height

% Enhanced page style
\\pagestyle{fancy}
\\fancyhf{}
\\fancyhead[L]{\\small\\textit{${topic}}}
\\fancyhead[R]{\\small\\textsc{${complexityLabel} Level}}
\\fancyfoot[C]{\\thepage}

% Code listings configuration
\\lstset{
    basicstyle=\\ttfamily\\footnotesize,
    breaklines=true,
    frame=single,
    numbers=left,
    numberstyle=\\tiny\\color{gray},
    backgroundcolor=\\color{gray!10},
    keywordstyle=\\color{blue},
    commentstyle=\\color{green!60!black},
    stringstyle=\\color{red},
    breakatwhitespace=false,
    captionpos=b,
    keepspaces=true,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

% Hyperref configuration
\\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=cyan,
    pdftitle={${topic} - Learning Guide},
    pdfauthor={AI Learning Document Generator}
}

\\title{\\textbf{${topic}}\\\\[0.5em]\\large A Comprehensive Learning Guide}
\\author{Generated by AI Learning Document Generator}
\\date{\\today}

\\begin{document}

\\maketitle

\\begin{abstract}
This document provides a comprehensive guide to ${topic} at the ${complexity} level. 
It covers fundamental concepts, practical applications, and detailed explanations 
designed to facilitate effective learning and understanding. The content is structured 
to build knowledge progressively, from foundational concepts to advanced applications.
\\end{abstract}

\\newpage`;
  }

  private generateTableOfContents(): string {
    return `\\tableofcontents
\\newpage`;
  }

  private generateDocumentFooter(): string {
    return `\\end{document}`;
  }

  async compileToPDF(latexContent: string, jobId: string): Promise<{ success: boolean; pdfPath?: string; error?: string }> {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const baseName = `document_${jobId}_${timestamp}`;
    const texPath = path.join(this.outputDir, `${baseName}.tex`);
    const pdfPath = path.join(this.outputDir, `${baseName}.pdf`);
    
    console.log(`üìÑ Starting PDF compilation for job ${jobId}`);
    console.log(`üìù LaTeX file: ${texPath}`);
    console.log(`üéØ Target PDF: ${pdfPath}`);
    
    try {
      // Write LaTeX content to file
      await fs.writeFile(texPath, latexContent, 'utf-8');
      console.log(`‚úçÔ∏è  LaTeX content written to ${texPath}`);
      
      // Compile LaTeX to PDF (run twice for proper references)
      const compilationResults = [];
      
      for (let pass = 1; pass <= 2; pass++) {
        console.log(`üîÑ Running pdflatex pass ${pass}/2...`);
        const result = await this.runPdfLatex(texPath, this.outputDir);
        compilationResults.push(result);
        
        if (!result.success) {
          console.error(`‚ùå Compilation failed on pass ${pass}:`, result.error);
          return { success: false, error: `Compilation failed on pass ${pass}: ${result.error}` };
        }
        
        console.log(`‚úÖ Pass ${pass} completed successfully`);
      }
      
      // Check if PDF was created
      try {
        await fs.access(pdfPath);
        console.log(`üéâ PDF generated successfully: ${pdfPath}`);
        
        // Clean up auxiliary files
        await this.cleanupAuxFiles(baseName, this.outputDir);
        
        return { success: true, pdfPath };
      } catch (error) {
        console.error(`‚ùå PDF file not found after compilation: ${pdfPath}`);
        return { success: false, error: 'PDF file not generated despite successful compilation' };
      }
      
    } catch (error) {
      console.error(`‚ùå Error during PDF compilation:`, error);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Unknown compilation error' 
      };
    }
  }
  
  private runPdfLatex(texPath: string, outputDir: string): Promise<{ success: boolean; error?: string }> {
    return new Promise((resolve) => {
      const pdflatex = spawn('pdflatex', [
        '-interaction=nonstopmode',
        '-output-directory', outputDir,
        texPath
      ]);
      
      let errorOutput = '';
      
      pdflatex.stdout.on('data', (data) => {
        // Suppress normal output, but could log for debugging
        // console.log(`pdflatex stdout: ${data}`);
      });
      
      pdflatex.stderr.on('data', (data) => {
        errorOutput += data.toString();
      });
      
      pdflatex.on('close', (code) => {
        if (code === 0) {
          resolve({ success: true });
        } else {
          resolve({ 
            success: false, 
            error: `pdflatex exited with code ${code}. Error: ${errorOutput}` 
          });
        }
      });
      
      pdflatex.on('error', (error) => {
        resolve({ 
          success: false, 
          error: `Failed to start pdflatex: ${error.message}` 
        });
      });
    });
  }
  
  private async cleanupAuxFiles(baseName: string, outputDir: string): Promise<void> {
    const auxExtensions = ['aux', 'log', 'out', 'toc', 'nav', 'snm'];
    
    for (const ext of auxExtensions) {
      const auxPath = path.join(outputDir, `${baseName}.${ext}`);
      try {
        await fs.unlink(auxPath);
        console.log(`üßπ Cleaned up ${auxPath}`);
      } catch (error) {
        // Ignore if file doesn't exist
        if ((error as NodeJS.ErrnoException).code !== 'ENOENT') {
          console.warn(`‚ö†Ô∏è  Could not clean up ${auxPath}:`, error);
        }
      }
    }
  }

  validateLatexContent(content: string): { valid: boolean; errors: string[] } {
    const errors: string[] = [];
    
    // Basic validation checks
    if (!content.includes('\\begin{document}')) {
      errors.push('Missing \\begin{document}');
    }
    
    if (!content.includes('\\end{document}')) {
      errors.push('Missing \\end{document}');
    }

    // Check for balanced braces (simplified)
    const openBraces = (content.match(/{/g) || []).length;
    const closeBraces = (content.match(/}/g) || []).length;
    
    if (openBraces !== closeBraces) {
      errors.push('Unbalanced braces detected');
    }

    return {
      valid: errors.length === 0,
      errors
    };
  }

  generateSampleDocument(): string {
    return `\\documentclass[12pt]{article}
\\usepackage[utf8]{inputenc}
\\usepackage{amsmath}
\\usepackage{graphicx}

\\title{Sample Learning Document}
\\author{AI Generator}
\\date{\\today}

\\begin{document}

\\maketitle

\\section{Introduction}
This is a sample document generated by the Learning Document Generator.

\\section{Main Content}
The main content would be generated by Ollama based on the user's topic request.

\\subsection{Key Concepts}
Important concepts would be explained here with proper formatting.

\\section{Conclusion}
Summary and final thoughts.

\\end{document}`;
  }
}
